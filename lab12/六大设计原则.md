### 论述利斯科夫替换原则（里氏代换原则）、单一职责原则、开闭原则、德（迪）米特法则、依赖倒转原则、合成复用原则，结合自己的实践项目举例说明如何应用 （保存到每个小组选定的协作开发平台上，以组为单位）

#### 里氏替换原则（Liskov Substitution Principle,简称LSP）

- **核心思想：** 在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。
- **通俗来讲：** 只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。
- **好处：** 增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。
- **需注意：** 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。

#### 单一职责原则（Single Responsibility Principle，简称SRP ）

- **核心思想：** 应该有且仅有一个原因引起类的变更
- **问题描述：** 假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。
- **好处：** 类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。
- **需注意：** 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。

#### 开放封闭原则（Open Close Principle,简称OCP）

- **核心思想：** 尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
- **通俗来讲：** 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。

#### 迪米特法则（Law of Demeter,简称LoD）

- **核心思想：** 类间解耦。
- **通俗来讲：** 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。

#### 依赖倒转原则（Dependence Inversion Principle,简称DIP）

- **核心思想：** 高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
- **说明：** 高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。
- **通俗来讲：** 依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。
- **问题描述：** 类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。
- **解决方案：** 将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。
- **好处：** 依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。

#### 合成复用原则（Composite/Aggregate Reuse Principle ，简称CARP）

- **核心思想：** 即在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。就是说要尽量的使用合成和聚合，而不是继承关系达到复用的目的。
- **通俗来讲：** 尽量使用组合/聚合，不要使用类继承。
- 组合和聚合都是关联的特殊种类。
- **需注意：什么时候才应该使用继承**
- 只有当以下的条件全部被满足时，才应当使用继承关系：
  - 派生类是基类的一个特殊种类，而不是基类的一个角色，也就是区分"Has-A"和"Is-A"。只有"Is-A"关系才符合继承关系，"Has-A"关系应当用聚合来描述。
  - 永远不会出现需要将派生类换成另外一个类的派生类的情况。如果不能肯定将来是否会变成另外一个派生类的话，就不要使用继承。
  - 派生类具有扩展基类的责任，而不是具有置换掉（override）或注销掉（Nullify）基类的责任。如果一个派生类需要大量的置换掉基类的行为，那么这个类就不应该是这个基类的派生类。
  - 只有在分类学角度上有意义时，才可以使用继承。

**一句话概括：** 单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。

#### 项目上的应用

对于依赖倒置原则，我们做了深入探究，以下是一些概念理解：

**依赖：** 在程序设计中，如果一个模块a使用/调用了另一个模块b，我们称模块a依赖模块b。

**高层模块与低层模块：** 往往在一个应用程序中，我们有一些低层次的类，这些类实现了一些基本的或初级的操作，我们称之为低层模块；另外有一些高层次的类，这些类封装了某些复杂的逻辑，并且依赖于低层次的类，这些类我们称之为高层模块。

传统的结构化程序设计中，高层模块总是依赖于低层模块，如下图所示。

![image-20220602200239924](%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.assets/image-20220602200239924.png)

这样的系统“高层模块”过分依赖“低层模块”，具体体现在以下方面：

- 系统很难改变，因为每个改变都会影响其他很多部分。
- 当你对某地方做一修改，系统的看似无关的其他部分都不工作了。
- 系统很难被另外一个应用重用，因为很难将要重用的部分从系统中分离开来。

而一个良好的设计应该是系统的每一部分都是可替换的。如果“高层模块”过分依赖“低层模块”，一方面一旦“低层模块”需要替换或者修改，“高层模块”将受到影响；另一方面，高层模块很难可以重用。

因此，我们应用**依赖倒置原则（Dependency Inversion Principle ，DIP）** ，**在高层模块与低层模块之间，引入一个抽象接口层** 。

![image-20220602200556145](%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.assets/image-20220602200556145.png)

即High Level Classes（高层模块） --> Abstraction Layer（抽象接口层） --> Low Level Classes（低层模块）

**抽象接口是对低层模块的抽象，低层模块继承或实现该抽象接口。**

这样一来，高层模块不直接依赖低层模块，而是依赖抽象接口层。抽象接口也不依赖低层模块的实现细节，而是低层模块依赖（继承或实现）抽象接口，**类与类之间都通过抽象接口层来建立关系** 。用面向对象技术将两个单元之间的依赖关系颠倒，接触循环。两种解决方法使用后都应形成树形结构，每棵子树都是系统的一部分，可以一次一个软件单元地增量开发系统，依次实现该项目的几个模块。
